Слово class в javascript является зарезервированным, поэтому внутри JSX синтаксиса необходимо писать className.

У каждого компонента могут быть свойства. Они хранятся в this.props, и передаются компоненту как атрибуты.
Значение свойства должно быть взято в фигурные скобки.
this.props используются только для чтения!

Комментарии внутри JSX (в App.js) пишутся в фигурных скобках: {/* текст комментария */}

Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

Внутри return всегда должен возвращаться DOM-узел (что угодно, обернутое в родительский тэг)

Реакту нужна уникальность, чтобы все его механизмы работали корректно. По "ключу" он будет понимать с каким именно дочерним
узлом вы работаете и какому родителю он принадлежит(Мы использовали у родительского элемента атрибут key (<div key={index}>)

React.createClass({
  propTypes: {
    // Вы можете указать, каким примитивом должно быть свойство
    optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,
    // Вы может указать, что свойство можеть быть одни из ...
    optionalUnion: React.PropTypes.oneOfType([
      React.PropTypes.string,
      React.PropTypes.number,
      React.PropTypes.instanceOf(Message)
    ]),
    // Вы можете указать, конкретную структуру объекта свойства
    optionalObjectWithShape: React.PropTypes.shape({
      color: React.PropTypes.string,
      fontSize: React.PropTypes.number
    }),
    // Вы можете указать, что свойство ОБЯЗАТЕЛЬНО
    requiredFunc: React.PropTypes.func.isRequired,
    // Если нужно указать, что свойство просто обязательно, и может быть любым примитивом
    requiredAny: React.PropTypes.any.isRequired,
  }
});

Для динамических свойств нужно использовать this.state 

Если вы определяете какое-то изменяемое свойство в компоненте, необходимо указать начальное
состояние (initial state). Для этого, у компонента указывается метод getInitialState.

Для обработки клика, используется свойство onClick + функция-обработчик.В качестве обработчика у нас будет
функция, которая изменяет состояние. Для изменения состояния, используется метод setState, который принимает
объект с аргументами, которые нужно изменить.

Нельзя вызывать setState в render !

++ перед переменной (префикс) - сначала увеличивает ее на 1, а потом возвращает значение;
++ после переменной (постфикс) - сначала вернет значение, а потом увеличит значение переменной;

Главное отличие неконтролируемого компонента от контролируемого в том, что у него нет обработчика
изменений, а значит нет постоянных вызовов setState и перерисовок.

У каждого компонента, есть жизненый цикл (lifecycle):Lifecycle methods
componentWillMount - компонент будет примонтирован
componentDidMount - компонент примонтировался
componentWillReceiveProps - компонент получает новые props
componentWillUpdate - вызывается прямо перед render, когда новые props и state получены. В этом методе нельзя вызывать setState
componentDidUpdate - вызывается сразу после render. Не вызывается в момент первого render'а компонента
componentWillUnmount - вызывается сразу перед тем, как компонент будет удален из DOM

Используем  библиотеку EventEmitter для необходимости взаимодействия двух компонентов,которые не состоят в отношении родитель-потомок










